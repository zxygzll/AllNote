mspaint       --调出画板
calc          --计算器
notepad       --调出记事本
md
rd /s /q aaa 安静的删除aaa文件
rd /s  aaa  询问你是否删除文件
dir
cls
exit
简单而言：使用jdk（java Development kit及java开发环境）开发java程序，
交给jre(java runtime enviroment及java环境运行)去运行，jvm保证跨平台行
path和classpath的区别
  path环境变量里面记录的是可执行文件，如.exe文件，对可执行的文件现在当前的路径去找，
如果没有找到就去path环境变量中配置的路径去找
  classpath环境变量里记录的是java类的运行文件所在的目录
方法之间是平级关系，不能嵌套定义
如果方法有明确的返回自一定要用return
java程序为了提高程序的效率，对数据进行了不同空间的分配
集体的是划分为5个内存空间
栈：存放局部变量
堆：存放的是new出来的所有的东西
方法区：
本地方法区（和具体的系统有关）
寄存器（CPU有关）

绿色版的软件解压就可以使用，删除文件夹就可以卸载
安装版的软件必须安装，直接删除并没有卸载，他会在注册表里留下它的信息，用专业的卸载工具把它卸载

API(Application Programming Interface)应用程序编程接口

堆内存的特点
A：每一个new出来的东西都有地址
B：每个变量都有默认值
    byte,short,int,long  ---0
    float,double         ---0.0
    boolean              ---false
    char                 ---'\u0000'
    引用类型             ---null
C：使用完毕之后就变成垃圾，但是并没有立即回收，会在垃圾回收器空闲的时候回收
栈内存的数据就释放掉了

数组常见的两个常见的问题
    ArrayIndexOutOfBoundsException:数组索引异常
	原因是：你访问你不存在的索引
    NullPointException:空指针异常
	原因是：数组也已经不在指向堆内，而你还在使用数组名去访问元素
二维数组new int[m][];第一个必须给出，才可以看出有多少个一维数组，如果第二个没有明确
说明没有为之new空间，所以地址为null，可以单独的为之new一维数组的空间


1、面向对象的思想
  面向对象的思想是基于面向过程的思想
  面向过程的思想强调的是每一个功能的具体实现
  面向过程的思想是强调对象，然后对象再去调取具体的功能


2、成员变量和局部变量的区别
    A、在内存中的位置不同
	成员变量在类里，方法外
	局部变量在方法定义或者申明中
    B、在内存中的位置不同
	成员变量在堆中
	局部变量在栈中
    C、生命周期不同
	成员变量随着对象的创建而存在，随着对象的消失而消失
	局部变量随着方法的调用而存在，随着方法的调用完而消失
    D、初始化值不同
	成员变量：因为在堆中有默认的初始值
	局部变量：没有默认的初始值，必须定义，赋值，然后才能使用
    注意事项：
	成员变量的名称可以与局部变量的名称相同，方法中采用的是就近原则的方法
3、匿名对象：就是没有名字的对象
	匿名对象的应用场景
	  A、调用方法，仅仅调用一次的时候
		注意：调用多次的时候，不适合
		那么这种匿名调用有什么好处吗？
		    有，匿名函数调用完就是垃圾，可以被垃圾回收器回收
	  B、匿名对象可以作为实际参数传递

4、封装的概述
    影藏对象的属性和实现细节，对外提供公共的访问方式
    好处：
	影藏实现的细节，提供公共的访问方式
	提高代码的复用性
	提高安全性
    封装的原则
	将不需要对外提供的内容影藏起来
	把属性影藏起来，提供公共方法对其访问

5、构造方法
    给对象数据进行初始化
    如果我们没有给构造方法，系统将自动默认给一个构造方法，要是我们给了构造方法，系统将不会给构造方法
   格式：
	A、方法名与类名相同
	B、没有具体的返回中类型，连void都没有
	C、没有具体的返回值

6、变量什么时候定义为成员变量
    如果该变量是用来描述这个类的信息的，那么该变量应该定义为成员变量
	变量定义在哪里好呢？
		变量的范围越小越好，因为能及时的回收
7、static的特点（可以修饰成员变量，也可以修饰成员方法）
    A、随着类的加载而加载
	回想main方法
    B、优先于对象而存在     
    C、被类的所有的对象共享
	举例：
		饮水机（用静态修饰）
		水杯（不用静态修饰）
    D、可以通过类名去调用
	其实它本身也可以通过对象名去调用
	推荐使用类名调用

	静态修饰的内容一般我们称其为：与类相关的，类成员
8、public static void main(String[] args) {...}
    public:访问权限是最大的，由于main方法是被jvm调用的，所以权限要最大
    static:静态的，不需要创建对象，通过类名就可以。方便jvm调用
    void:因为我们经常说过，方法的返回值给调用者，而main方法是给jvm调用的，所以返回值没有任何的用处
    main:这是一个常见的方法入口
    String[] args:这是一个字符串数组。值去哪里了？这个东西到底怎么用？怎么给值
	这个东西最早期是为了接受键盘录入的数据的
	格式是：
	    java main方法的类名 字符串
	但是这之后不需要这样的从键盘输入字符串，因为我们有更强大的Scanner

9、继承的概述
    把多个类中相同的内容提取出来定义到一个类中
   如何实现呢？
	java提供了关键字：extends；不能继承私有的，继承只能继承无参的构造方法，不能继承带参的构造方法
   格式
	class自类名 extends 父类名{}
   好处：
	A、提高了代码的复用性
	B、提高了代码的维护性
	C、让类与类之间产生了关系，是多态的前提
   类与类之间产生了关系，其实也是继承额一个弊端：
	类的耦合性增强了。
	开发的原则：低耦合，高内聚
	耦合：类与类之间的关系
	内聚：就是自己完成某件事的能力
10、this和super的区别
    分别是什么呢？
	this表示本类的引用
	super表示父类存储空间的标示（可以理解为父类的引用）
    怎么用呢？调用
	A、调用成员变量
	    this.成员变量  调用本类的成员变量
	    super.成员变量 调用父类的成员变量
	B、调用构造方法
	    this(...) 调用本类的构造方法
	    super(...) 调用父类的构造方法
	C、调用成员方法
	    this.成员方法 调用本类的成员方法
	    super.成员方法 调用父类的成员方法
11、看程序写结果
    A、成员变量的问题
	int x = 10;//成员变量是基本类型
	Student s = new Student(); //成员变量是引用类型
    B、一个类的初始过程
	成员变量的初始化
	    默认初始化
	    显示初始化
 	    构造方法初始化
    C、子父类的初始化
	    先进行父类初始化，然后进行子类初始化
    问题：
	虽然之类中构造方法默认有一个super()
	初始化的时候，不是按照那个顺序进行的
	而是按照分层初始化进行的
	它仅仅表示要先初始化父类的书记，再初始化之类数据
12、方法重写的注意事项
    A、父类中私有方法不能被重写
	因为父类中私有方法根本无法被子类继承
    B、子类重写方法时，访问权限不能更低
	最好一致
    C、父类静态方法，子类也必须通过静态方法进行重写
    
    子类重写父类方法的时候，最好声明一模一样。
13、override方法重写
	在子类中，出现和父类中一模一样的方法申明的现象

    overload方法重载
	在听一个类中，出现方法名相同，参数列表不同的现象
	方法重载能改变返回值类型，因为它与返回值类型无关
    this关键字和super关键字
	this:代表当前类的对象引用
	super:代表父类存储空间的标识（可以理解为父类的引用，通过这个东西可以访问父类里面的成员）
14、final可以修饰类，方法，变量
    特点：
	final可以修饰类，该类不能被继承（最终类）
	final可以修饰方法，改方法不能被重写（最终方法）
	final可以修饰变量，该变量不能被重新赋值，因为该变量其实是常量
    常量:
	A:自面值常量
	B:自定义常量
    final修饰变量的初始化时机
	A、被final修饰的变量只能赋值一次
	B、在构造方法完毕前。（非静态的常量）
15、多态中成员访问的特点
    A、成员变量
	编译看左边，运行看左边
    B、构造方法
	创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化
    C、成员方法
	编译看左边，运行看右边
    D、静态方法
	编译看左边运行看左边
	（静态和类相关，算不上重写，所以访问还是左边）

	由于成员方法存在方法重写，所以它运行看右边
    多态的弊端
	不能使用子类特有的功能
    我就想使用子类特有的功能？行不行？
	行。

    怎么用呢？
	A：创建子类对象调用方法即可（可以，但是很多时候不合理，而且占的内存较大）
	B：把父类的引用强制转换为子类的引用（向下转类型）
    对象之间的转型问题：
	向上转型
	    Fu f = new Zi();
	向下转型
	    Zi z = (Zi)f     //要求必须是能转换为Zi的

    多态中常见的异常ClassCastException(类转换异常)eg:猫强制准换成狗
16、抽象类的概述：
    我们把不是一个具体的功能称为抽象功能，而一个类中如果有抽象功能，该类必须是抽象类。
    抽象类的特点：
	A：抽象类和抽象方法必须用abstract关键字进行修饰
	B：抽象类中不一定有方法，但是有抽象方法的必须定义为抽象类
	C：抽象类不能实例化
	    因为它不是具体的
	    抽象类有构造方法，但是不能实例化，构造方法有什么作用呢
		用于子类访问父类数据的初始化

	D:抽象的子类
	    	a:如果不想重写抽象方法，那么该子类是一个抽象类
		b:重写所有的抽象方法，这个时候子类是一个具体的类

	抽象类的实例化其实就是靠子类实现的。是多态的方式
		Animal a = new Cat();
    一个类如果没有抽象方法，可不可以定义为抽象类？如果可以，有什么意义
	可以；意义：不能用创建对象来访问
    抽象类不能与那些关键字共存
	private 冲突
	final   冲突
        static  无意义
17、接口的特点
    A、接口用关键字interface表示
	interface 接口名 {}
    B、类的实现用implements表示
	class 类名 implements 接口名
    C、接口不能实例化
	那么，接口如何实例化呢？
	按照多态的方式来实例化
    D、接口的子类
	a:可以是抽象类，但是意义不大
	b:可以是具体类。但是要重写接口中所有的抽象方法（推荐使用）
    由此可见：
	A：具体类多态（几乎没有）
	B：抽象类多态（常见）
	D：接口多态（最常见）
    接口成员特点
	成员变量：接口中的成员变量默认是常量，并且是静态的public static final(默认的)（自定手动的给出）
	构造方法：接口中没有构造方法
	成员方法:只能是抽象方法
		默认修饰符：public abstract
		建议：自己手动给出。

    所有的类都默认继承自一个类：Object
 	类 Object 是类层次结构的根类。每个类都使用 Object 作为超类。所有对象（包括数组）都实现这个类的方法。 

    类与类
	继承关系，只能是但继承，可以多层继承
    类与接口
	实现关系，可以是单实现，也可以是多实现
	而且可以在继承一个类的同时实现多个接口
    接口与接口
	继承关系，可以但继承，也可以多继承
18、抽象类与接口的区别‘
    A、成员区别：
	抽象类
	    成员变量：可以变量，也可以是常量
	    构造方法：有
	    成员方法：可以抽象，也可以是非抽象
	接口：
	   成员变量：只能是常量
	   构造方法：无
	   成员方法：只可以抽象
    B、关系区别
	类与类
	    继承，单继承
	类与接口
	    实现，单显示，多实现
	接口与接口
	    继承，单继承，多继承
    C、设计理念区别
	抽象类 被继承的体现的是："is a"的关系
	接口 被实现体现的是："like a"的关系
相关的总结：
    1、final关键字
	（1）是最终的意思，可以修饰类，方法，变量
	（2）特点：
	    A:它修饰的类不能被继承
	    B：它修饰的方法不能被重写
	    C：它修饰的变量是一个常量
	（3）面试相关
	    A：局部变量
		a:基本类型 值不能改变
		b:引用类型 地址值不能发生改变，但是对象的内容是可以改变的
	    B：初始化时机
		a:只能初始化一次
		b:常见的给值
		    定义的时候（推荐）
		    构造方法中
    2、多态
	（1）同一个对象在不同时刻体现出来的不同的状态
	（2）多态的前提
	    A:有继承或者实现的关系
	    B：有方法的重写
	    C：有父类
    3、抽象类
    4、接口
19、形式参数
    基本类型
    引用类型
	类名：需要的是该类的对象
	抽象类：需要的是该抽象的类子类的对象
	接口：需要的是该接口的实现对象
20、包
    A、其实就是文件夹
    B、作用
	a、对类进行分类管理
	b、把相同的类名放到不同的包中
    举例：
	学生：增加，删除，修改，查询
	老师：增加，删除，修改，查询
	。。。。
	方案1：按功能分
	    cn.itcast.add
		AddStudent
		AddTeacher
	    cn.itcast.delete
		DeleteStudent
		DeleteTeacher
	    cn.itcast.update
		UpdateStudent
		UpdateTeacher
	    cn.itcast.find
		FindStudent
		FindTeacher
	方案2：按模块分
	    cn.itcast.teacher
		AddTeacher
		DeleteTeacher
		UpdateTeacher
		FindTeacher
	    cn.itcast.student
		AddStudent
		DeleteStudent
		UpdateStudent
		FindStudent
    注意事项
	A：package语句必须是程序的第一条可执行语句（级最顶上）
	B：package语句在一个java文件中只能有一个
	C：如果没有package,默认表示无包名
	    
    权限修饰符
		    	本类	同一个包下（子类和无关类）	不同包下（子类）	不同包下（无关类）
	private		Y	
	默认		Y	Y
	protected	Y	Y				Y
	public		Y	Y				Y				Y
    
    修饰符：
	权限修饰符：private，默认的,protected,public
	状态修饰符：static,final
	抽象修饰符：abstract

    类：
	权限修饰符：默认修饰符，public
	状态修饰符：final
	抽象修饰符:abstract

	用得最多的就是：public
    成员变量：
	权限修饰符:private，默认的,protected,public
	状态修饰符:static,final
	抽象修饰符

	用得最多的就是：private(然后用getXXX/setXXX)
    构造方法：
	权限修饰符:private，默认的,protected,public
	状态修饰符
	抽象修饰符

	用得最多的就是：public
    成员方法：
	权限修饰符:private，默认的,protected,public
	状态修饰符:static,final
	抽象修饰符：abstract

	用得最多的就是private

	除此之外的组合规则
	    成员变量：public static final(接口中)
	    成员方法：public static
		      public abstract(抽象中)
		      public final(最终类，不能被继承)
21、内部类
    在类里面的类叫做内部类
    成员内部类：位置在成员的位置
	成员内部类的修饰符：
	    private 为了保证数据的安全性，可以提供一个公共的方法就行访问，跟成员变量很相似
	    static 为了方便访问数据
		静态内部类访问的外部的数据必须用静态修饰
    注意：
	1：内部类和外部类没有继承关系
	2：通过外部类名限定this对象
	 	Outer.this
    局部内部类
	A：可以直接访问外部内的成员
	B：在局部位置，可以创建内部类对象，通过对象调用内部方法，来使用局部内部类的功能
	面试题：
		局部内部类访问的局部变量必须用final修饰
		为什么呢？
			局部变量是随着方法的调用而调用，调用完毕就消失
			而堆内存的内容不会立即消失，所以我们用final修饰
			加入final修饰之后，这个变量就变成了常量
    匿名内部类
	就是内部类的简化写法
    前提：存在一个类或者接口
	这里的类可以时候具体类也可以是抽象类
    格式：
	new 类名或者接口名（）{
		重写方法；
	}
    本质是什么呢？
	是一个继承了该类或者实现了该接口的子类匿名对象

    总结：
	参数：
	    （1）形式参数
		类名：需要该类的对象
		抽象类名：需要该类的子类对象
		接口名：需要该接口的实现类对象
	    （2）返回值类型
		类名：需要该类的对象
		抽象类名：返回的是该类的子类对象
	    
		接口名：返回的是该接口的实现类的对象
	    （3）链式编程
		对象.方法1（），方法2（）......方法n（）；
		这种用法：方法1（）调用完毕之后，应该返回的是一个对象，
			  方法2（）调用完毕之后，应该返回的是一个对象
			  ......
			  方法n()调用完毕之后，可能是对象，也可以不是对象
22、jdk用的是多少位的eclipse就用多少位的，而不是系统多少位就用多少位的eclipse.
23、eclipse中常用的快捷键
    1、格式化ctrl+shift+f
    2、导入包ctrl+shift+o
	如果在该类仅仅在一个包中，就自己显示了
	如果该类在多个包中标，就会弹出一个框框供你选择
    3、注释
	单行：注释ctrl+/,取消再来一次
	多行：ctrl+shift+/,取消注释ctrl+shift+\
    4、代码上下移动
	选中代码alt+上/下箭头
    5、查看源码
	选中类名（F3或者ctrl+鼠标点击）
24、常见的对象方法
	public String toString();  //返回对象的字符串表示
	Integer类下的一个静态方法
		public static String toHexString(int i);   //把一个整数转换成一个十六进制的字符串
	对象.hashCode()以哈希的计算方式计算的对象的地址，返回的是一个整数
25、String s = new String("hello")和String s="hello"的区别？
	有，前者创建的是2个对象，后者创建1个对象
	注意：==比较引用型比较的是地址值是否相同
	      equals:比较引用类型默认也是比较地址值是否相同，而String类重写了equals()方法，比较的是值是否相同

26、String,StringBuffer,StringBuilder的区别
    A、String是内容不可变，StringBuffer和StringBulider都是内容可变的
    B、StringBuffer是同步的，数据安全，效率低；StringBulider是不同步的，数据不安全，效率高
27、StringBuffer数组的区别？
    二者都可以看成是一个容器，装其他的数据。
    但是，StringBuffer的数据最终是一个字符串的数据
    而数组可以放置很多种数据，单必须都是同一种数据类型的数据
28、形式参数问题
    String作为参数传递
    StringBuffer作为参数传递

	形式参数：
		基本类型：形式参数的改变不影响实际的参数
		引用类型：形式参数的改变直接影响实际参数
	注意：String作为参数的传递，效果和基本类型参数传递是一样的
29、为了对基本类型进行更多的操作，java就提供了每一种基本类型对应的操作类
	byte	Byte
	short	Short
	int	Integer
	long	Long
	float	Float
	double	Double
	char	Char
	boolean	Boolean
	基本类型与字符串之间的转换
30、Integer的数据的直接赋值，如果在-128到127之间，会之间从缓冲池中获取数据
31、硬盘上的路径用//代替一个/
32、由于在运算的时候，float和double很容易丢失精度，为了能精确的表示和计算浮点数，java提供了BigDecimal
33、从Date到毫秒值
	getTime()
    从毫秒值到Date
	构造方法
	setTime(long time)
34、数组和集合的区别
	A、长度区别
		数组的长度是固定的
		集合的长度的可变的
	B、内容不同
		数组存储的是同一种类型的元素
		集合可以存储不同类型的元素
	C、元素的数据类型问题
		数组可以存储基本类型，也可以存储引用类型
		集合只能存储引用类型
35、数组，集合，字符串那些有length()方法
	只有字符串有
	数组length
	集合size()
36、集合的使用步骤
	A、创建集合对象
	B、创建元素对象
	C、把元素对象添加到集合中
	D遍历集合
		a:通过集合获取迭代器对象
		b:通过迭代器对象的hasNext()判断是否有元素
		c:通过迭代器对象的next()方法获取元素并移动到下一个位置
37|、迭代器为什么不定义成一个类，而是一个接口？
	假设迭代器定义为一个类，这样我们就可以创建该类的对象，调用该类的方法来实现集合的遍历
。但是呢？java提供了很多的集合类，而这些集合类的数据结构是不同的，所以存储方式和遍历方式也不同，最终
没有定义为迭代器类。
	而无论你是那种集合，你都应该具备获取元素的操作，并且最好在辅助于判断功能，这样在获取前先判断
这样就更不容易出错，也就是说判断功能和获取功能是一个集合所必备的。而每一种集合的方式又不一样，所以
它们把这个功能提取出来，并不提供具体的实现，这就是接口
	那么真正写的实现类在哪里呢
		在具体的子类中，在子类的内部类中实现
38、List集合的特点：
	有序（存储和取出的元素一致），可重复
    List集合特有的遍历功能
	size()和get()方法的结合使用
39、常见的数据结构的优缺点
	数据结构+算法
40、数组查询块，增删慢
    链表查询慢，增删快
41、List:(面试List的子类特点)
	ArrayList:
		底层数据结构是数组，查询快，增删慢
		线程不安全，效率高
	Vector:
		底层数据结构是数组，查询快，增删慢
		线程安全，效率低
	LinkedList;
		底层数据结构是链表，查询慢，增删快
    List有三个儿子，我们到底使用谁呢？
	要安全？
		要：Vector(即使安全也不用它了，后面有替换的)
		不要：ArrayList和LinkedList
			查询多？用ArrayList
			增删多？LinkedList
	要是忘了，不懂就通用ArrayList(毕竟查询比增删的情况多)
42、泛型高级（通配符）
    ?:任意类型，如果没有明确，那么就是Object及任意的java类了
    ? extends E    向下限定，E及其子类
    ? super E      向上限定，E及其父类
43、静态导入的概述及使用
	格式：import static 包名....类名.方法名；
 	可以直接导入到方法类别
    注意事项
	方法必须是静态的
	如果有多个同名的静态方法，容易不知道使用谁？这个时候要使用，必须加前缀。
44、可变参数：定义方法的时候不知道该定义多少个参数
	格式：
		修饰符 返回值类型 方法名（数据类型... 变量名）{}
	注意：
		这里的变量其实是一一个个数组
		如果一个方法有可变参数，那么，可变参数肯定是最后
	refactor(重构)  Extract Method(抽取方法)
45、TreeSet集合保证元素排序和唯一性的原理
	唯一性：是根据比较的返回是否是0来决定（是0就不搭理它）
	排序：
		A：自然排序（元素具备比较器）
			让元素所属的类实现自然接口Comparable
		B：比较器排序（集合具备比较器）
			让集合的构造方法接收一个比较器接口的子类对象Comparable
Collection集合总结
	List 有序，可重复
		ArrayList
			底层数据是数组，查询快，增删慢
			线程不安全，效率高
		Vector
			底层数据是数组，查询快，增删慢
			线程安全，效率低
		LinkedList
			底层数据是链表，查询慢，增删快
			线程不安全，效率高
	Set 无序，唯一
		HashSet
			底层数据结构是哈希表
			如何保证元素的唯一性的呢？
				依赖两个方法：hashCode()和equals()
				开发中自动生成两个方法即可
			LinkedHsahSet
				底层数据是哈希表和链表
				由链表保证元素有序
				哈希表保证元素的唯一
		TreeSet
			底层数据是红黑树
			如何保证元素排序的呢？
				自然排序
				比较器排序
			如何保证元素的唯一的呢？
				根据比较的返回值是否是0来决定

针对Collection集合我们到底使用谁呢？
	唯一吗？
		是Set
			排序吗？
				是：TreeSet
				否：HashSet
		如果不知道用那个Set就用HashSet
		否List
			要安全吗？
				是：Vector
				否：ArrayList或者LinkedList
					查询多：ArrayList
					增删多：LinkedList
		如果你不知道用那个List就用ArrayList
	如果你知道是Collection集合，但是不知道使用谁，就用ArrayList

在集合中常见的数据结构
	ArrayXXX:底层是数组，查询快，增删慢
	LinkedXXX:底层是链表，查询慢，增删快
	HsahXXX：底层是哈希表。依赖两个方法：hashCode()和equals()
	TreeXXX:底层是二叉树。两种方法排序：自然排序和比较器排序

46、编译时期抛出异常，将来调用者必须处理
    运行时期抛出异常，将来调用可以不用处理
47、throws和throw的区别
	throws
		用在方法申明后面，跟的是异常名
		可以跟多个异常名，用逗号隔开
		表示抛出异常，由该方法的调用者来处理
		throws表示出现异常的一种可能性，并不一定会发生这些异常
	throw
		用在方法体内，跟的是异常对象名
		只能抛出一个异常对象名
		表示抛出异常，由方法体内的语句处理
		throw则是抛出了异常，执行throw则一定抛出了某种异常
	我们该怎样使用异常
		原则：如果该功能内部可以将问题处理，就用try，如果处理不了，交给调用者处理，用throws
		区别：
			后续程序需要继续处理就用try
			后续程序不需要继续处理就用throws
48、final,finally和finalize的区别
	final：是最终的意思，可以修饰类，成员变量，成员方法
		修饰类，不能被继承
		修饰方法：不能被继承
		修饰变量：是常量
	finally:是异常处理的一部分，用于释放资源
		一般来说，代码肯定会执行，特殊情况下：在执行到finally之前jvm退出了
	finalize:是Obiect类的一个方法，用于垃圾回收